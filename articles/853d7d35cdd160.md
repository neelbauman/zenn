---
title: "pythonProjectで自動バージョニングでリリースするケース"
emoji: "🌟"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [git, uv]
published: true
---

# uvとhatch-vcsによる動的バージョニング移行：PyPI 400エラーと無限ループの解消

PythonのOSS開発において、`pyproject.toml` や `__init__.py` に直書きされたバージョン番号の不整合は、リリース作業における典型的な技術的負債である。

本記事では、Pythonパッケージマネージャ `uv` を用いたプロジェクトにおいて、バージョン管理をGitタグに一元化する「動的バージョニング（`hatch-vcs`）」へ移行した際の記録を共有する。

特に移行プロセスで直面した2つの特有の課題（PyPIアップロードエラーと自動生成ファイルの無限ループ）とそのメカニズム、解決策について解説する。

## 1. 事象：手動バージョン管理の限界と移行

これまで、プロジェクトでは自作のスクリプト（`bump_version.py`）を用いて複数ファイルのバージョン文字列を書き換えていた。しかし、手作業であるため不整合のリスクが高まり、リリース作業の負担となっていた。

そこで、「Gitのタグを唯一の正解（Single Source of Truth）」とする構成へ刷新するため、ビルドバックエンドを `uv_build` から `hatchling` に変更し、プラグインである `hatch-vcs` を導入した。

```toml:pyproject.toml
[build-system]
requires = ["hatchling", "hatch-vcs"]
build-backend = "hatchling.build"

[project]
name = "beautyspot"
dynamic = ["version"]  # ハードコードを廃止

[tool.hatch.version]
source = "vcs"

[tool.hatch.build.hooks.vcs]
version-file = "src/beautyspot/_version.py"

```

この設定により、`uv build` 実行時にGitタグから自動的にバージョンが算出される。しかし、実際のリリースフローに組み込む過程で2つの罠に陥った。

## 2. 課題1：PyPIアップロード時の 400 Bad Request

移行後、初めてビルドとPyPIへのアップロード（`uv publish`）を試みた際、以下のエラーが発生してデプロイが失敗した。

```bash
error: Failed to publish `dist/beautyspot-2.2.6.dev9+gbd456d23d.d20260202.tar.gz`
Caused by: Upload failed with status code 400 Bad Request. Server says: 400 The use of local versions in <Version('2.2.6.dev9+gbd456d23d.d20260202')> is not allowed.

```

### なぜローカルバージョンが生成されたのか

PyPIは仕様上、`+` を含むローカルバージョン識別子（Local Version Identifiers）のアップロードを許可していない。
`hatch-vcs` は、現在のGitのワークツリーが**「直近のタグと完全に一致していない状態」**である場合、自動的に開発用バージョン（例：`.dev9+gbd456d23d`）を算出する仕様となっている。

当時の状況は以下のいずれかに該当していた。

* 新しいタグ（`v2.2.6`）を打つ前にビルドを実行してしまった。
* Gitでコミットされていない変更（Dirtyな状態）が残っていた。

**対処法:** リリースビルドを行う際は、必ず変更を全てコミットし、**Gitタグを打ってから** `uv build` を実行する必要がある。

## 3. 課題2：_version.py コミットの無限ループ

課題1を解決するためにコミットとタグ打ちを行ったが、今度は別の問題が発生した。
`uv build` を実行するたびに、`hatch-vcs` の設定で指定した `src/beautyspot/_version.py` が新規作成・更新されてしまい、Gitの差分（変更あり）として検知されてしまうのである。

このファイルをコミットするとHEADがタグから1つ進んでしまい、再び「タグと一致しない状態」になり、課題1のエラー（ローカルバージョンの生成）が再発する「無限ループ」に陥った。

### 仕組みの理解と解決策

`_version.py` はソースコードではなく、ビルド時に動的に生成される**成果物（Artifact）**である。したがって、Gitの管理下に置くべきではない。

**対処法:** `.gitignore` に生成されるバージョンファイルを追加し、Gitの追跡対象から外す。

```text:.gitignore
# Generated version file
src/beautyspot/_version.py

```

追跡から外しても問題はない。`uv build` が実行される際、`hatchling` が生成された `_version.py` を自動的にWheelパッケージの中に物理的に梱包してくれるため、PyPIからインストールしたユーザーの手元には正しいバージョン情報が届く仕様になっている。

## 4. 対処法：新しいリリースフローの確立

最終的に、手動のバンプスクリプトや複雑なチェックロジックを捨て、以下のシンプルなフローに到達した。

1. **変更の確定:** `git commit -m "feat: new feature"`
2. **バージョンの確定:** `git tag v2.3.0`
3. **リリースの実行:** `make release` （Makefileのreleaseコマンド内部で `uv build` と `uv publish` を実行）

これにより、ファイルの書き換え忘れによる不整合は構造上発生しなくなり、リリースマネジメントの安全性が劇的に向上した。

## まとめ

* 手動によるバージョンファイルの同期は、`hatch-vcs` を用いた動的バージョニングへの移行で根本解決できる。
* PyPIの `400 Bad Request` は、Gitタグと現在のコミット状態が一致しておらず、開発用ローカルバージョンが生成されたことに起因する。
* リリースビルドの前に、必ずクリーンな状態でGitタグを打つ必要がある。
* `hatch-vcs` が自動生成する `_version.py` は `.gitignore` に追加し、Gitで追跡してはならない（無限ループの原因になるため）。
* ビルドツール（`hatchling`）の適切な設定により、Gitの追跡外であっても最終的なパッケージには正しくバージョン情報が同梱される。

